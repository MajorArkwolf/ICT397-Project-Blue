#pragma once

	/// Internal Dependencies
#include "Controller/Engine/LuaManager.hpp"
#include "../Types.hpp"
#include "../Base.hpp"
#include "../Static.hpp"
#include "../Item.hpp"
#include "../Character.hpp"
#include "../Player.hpp"
#include "../NPC.hpp"

	/*!
	 * @brief A simple set of functions that can be used to get the GameObject type identifiers.
	 * @note Exists to provide an easy way to get all values of the enum for scripting.
	 */
namespace GameObj_LuaHelper {
		//! Returns GameObj_Type::Invalid
	GameObj_Type Invalid();

		//! Returns GameObj_Type::Static
	GameObj_Type Static();

		//! Returns GameObj_Type::Item
	GameObj_Type Item();

		//! Returns GameObj_Type::Player
	GameObj_Type Player();

		//! Returns GameObj_Type::NPC
	GameObj_Type NPC();

		/*!
		 * @brief A wrapper class to operate on status and AI properties & operations through scripting.
		 * @note This bypasses the memory issues generated by directly operating on a virtually-derived class in Lua.
		 */
	class CharacterWrapper {
	public:
			//! Use of the default constructor is disallowed
		CharacterWrapper() = delete;

			/*!
			 * @brief Class constructor, guarantees that an object address to proxy is assigned.
			 * @param [in] target A pointer to an existing GameObj_Character.
			 */
		CharacterWrapper(GameObj_Character* target);

			/*!
			 * @brief Calls type() on the encalsulated GameObj_Character.
			 * @return The type of encapsulated GameObject, or GameObj_Type::Invalid on error.
			 * @see GameObj_Character::type()
			 * @warning Calling this when the proxy is in an invalid state can damage memory!
			 */
		GameObj_Type type();

			/*!
			 * @see GameObj_Character::status_assign()
			 * @warning Calling this when the proxy is in an invalid state can damage memory!
			 */
		void status_assign(std::string key, float value);

			/*!
			 * @see GameObj_Character::status_count()
			 * @warning Calling this when the proxy is in an invalid state can damage memory!
			 */
		unsigned long long status_count();

			/*!
			 * @see GameObj_Character::status_has()
			 * @warning Calling this when the proxy is in an invalid state can damage memory!
			 */
		bool status_has(std::string key);

			/*!
			 * @see GameObj_Character::status_list()
			 * @warning Calling this when the proxy is in an invalid state can damage memory!
			 */
		std::vector<std::string> status_list();

			/*!
			 * @see GameObj_Character::status_get()
			 * @warning Calling this when the proxy is in an invalid state can damage memory!
			 */
		float status_get(std::string key);

			/*!
			 * @see GameObj_Character::status_delete()
			 * @warning Calling this when the proxy is in an invalid state can damage memory!
			 */
		void status_delete(std::string key);

			/*!
			 * @see GameObj_Character::status_clear()
			 * @warning Calling this when the proxy is in an invalid state can damage memory!
			 */
		void status_clear();

			/*!
			 * @brief Returns a copy of the GameObject's FSM Identifier.
			 * @return A copy of the FSM context identifier value, defaulting to 0u if not found.
			 * @note Return value will not default if the wrapped GameObject type is GameObj_Type::NPC.
			 * @see GameObj_NPC::context()
			 * @warning Calling this when the proxy is in an invalid state can damage memory!
			 */
		BlueEngine::ID npc_context();

			/*!
			 * @brief Checks if the wrapped GameObject is derived from GameObj_Character and not null.
			 * @return True if the Wrapper can be safely used, False otherwise.
			 */
		bool is_valid();

	private:
			//! Keeps track of the GameObj_Character to encapsulate from Lua.
		GameObj_Character* gameObj;
	};
};

// Registratiion of Enum GameObj_Type
namespace luabridge {
	template <>
	struct luabridge::Stack <GameObj_Type> : EnumWrapper <GameObj_Type> {};
}
